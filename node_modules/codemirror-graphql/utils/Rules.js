/**
 *  Copyright (c) 2015, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 */

'use strict';

exports.__esModule = true;

var _utilsRuleHelpers = require('../utils/RuleHelpers');

/**
 * Whitespace tokens defined in GraphQL spec.
 */
var isIgnored = function isIgnored(ch) {
  return ch === ' ' || ch === '\t' || ch === ',' || ch === '\n' || ch === '\r' || ch === 'ï»¿';
};

exports.isIgnored = isIgnored;
/**
 * The lexer rules. These are exactly as described by the spec.
 */
var LexRules = {
  // The Name token.
  Name: /^[_A-Za-z][_0-9A-Za-z]*/,

  // All Punctuation used in GraphQL
  Punctuation: /^(?:!|\$|\(|\)|\.\.\.|:|=|@|\[|\]|\{|\||\})/,

  // Combines the IntValue and FloatValue tokens.
  Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,

  // Note the closing quote is made optional as an IDE experience improvment.
  String: /^"(?:[^"\\]|\\(?:"|\/|\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*"?/
};

exports.LexRules = LexRules;
/**
 * The parser rules. These are very close to, but not exactly the same as the
 * spec. Minor deviations allow for a simpler implementation. The resulting
 * parser can parse everything the spec declares possible.
 */
var ParseRules = {
  Document: [_utilsRuleHelpers.list('Definition')],
  Definition: function Definition(token) {
    switch (token.value) {
      case '{':
        return 'ShortQuery';
      case 'query':
        return 'Query';
      case 'mutation':
        return 'Mutation';
      case 'subscription':
        return 'Subscription';
      case 'fragment':
        return 'FragmentDefinition';
      case 'schema':
        return 'SchemaDef';
      case 'scalar':
        return 'ScalarDef';
      case 'type':
        return 'ObjectTypeDef';
      case 'interface':
        return 'InterfaceDef';
      case 'union':
        return 'UnionDef';
      case 'enum':
        return 'EnumDef';
      case 'input':
        return 'InputDef';
      case 'extend':
        return 'ExtendDef';
      case 'directive':
        return 'DirectiveDef';
    }
  },
  // Note: instead of "Operation", these rules have been separated out.
  ShortQuery: ['SelectionSet'],
  Query: [word('query'), _utilsRuleHelpers.opt(name('def')), _utilsRuleHelpers.opt('VariableDefinitions'), _utilsRuleHelpers.list('Directive'), 'SelectionSet'],
  Mutation: [word('mutation'), _utilsRuleHelpers.opt(name('def')), _utilsRuleHelpers.opt('VariableDefinitions'), _utilsRuleHelpers.list('Directive'), 'SelectionSet'],
  Subscription: [word('subscription'), _utilsRuleHelpers.opt(name('def')), _utilsRuleHelpers.opt('VariableDefinitions'), _utilsRuleHelpers.list('Directive'), 'SelectionSet'],
  VariableDefinitions: [_utilsRuleHelpers.p('('), _utilsRuleHelpers.list('VariableDefinition'), _utilsRuleHelpers.p(')')],
  VariableDefinition: ['Variable', _utilsRuleHelpers.p(':'), 'Type', _utilsRuleHelpers.opt('DefaultValue')],
  Variable: [_utilsRuleHelpers.p('$', 'variable'), name('variable')],
  DefaultValue: [_utilsRuleHelpers.p('='), 'Value'],
  SelectionSet: [_utilsRuleHelpers.p('{'), _utilsRuleHelpers.list('Selection'), _utilsRuleHelpers.p('}')],
  Selection: function Selection(token, stream) {
    return token.value === '...' ? stream.match(/[\s\u00a0,]*(on\b|@|{)/, false) ? 'InlineFragment' : 'FragmentSpread' : stream.match(/[\s\u00a0,]*:/, false) ? 'AliasedField' : 'Field';
  },
  // Note: this minor deviation of "AliasedField" simplifies the lookahead.
  AliasedField: [name('property'), _utilsRuleHelpers.p(':'), name('qualifier'), _utilsRuleHelpers.opt('Arguments'), _utilsRuleHelpers.list('Directive'), _utilsRuleHelpers.opt('SelectionSet')],
  Field: [name('property'), _utilsRuleHelpers.opt('Arguments'), _utilsRuleHelpers.list('Directive'), _utilsRuleHelpers.opt('SelectionSet')],
  Arguments: [_utilsRuleHelpers.p('('), _utilsRuleHelpers.list('Argument'), _utilsRuleHelpers.p(')')],
  Argument: [name('attribute'), _utilsRuleHelpers.p(':'), 'Value'],
  FragmentSpread: [_utilsRuleHelpers.p('...'), name('def'), _utilsRuleHelpers.list('Directive')],
  InlineFragment: [_utilsRuleHelpers.p('...'), _utilsRuleHelpers.opt('TypeCondition'), _utilsRuleHelpers.list('Directive'), 'SelectionSet'],
  FragmentDefinition: [word('fragment'), _utilsRuleHelpers.opt(_utilsRuleHelpers.butNot(name('def'), [word('on')])), 'TypeCondition', _utilsRuleHelpers.list('Directive'), 'SelectionSet'],
  TypeCondition: [word('on'), type('atom')],
  // Variables could be parsed in cases where only Const is expected by spec.
  Value: function Value(token) {
    switch (token.kind) {
      case 'Number':
        return 'NumberValue';
      case 'String':
        return 'StringValue';
      case 'Punctuation':
        switch (token.value) {
          case '[':
            return 'ListValue';
          case '{':
            return 'ObjectValue';
          case '$':
            return 'Variable';
        }
        return null;
      case 'Name':
        switch (token.value) {
          case 'true':case 'false':
            return 'BooleanValue';
        }
        return 'EnumValue';
    }
  },
  NumberValue: [_utilsRuleHelpers.t('Number', 'number')],
  StringValue: [_utilsRuleHelpers.t('String', 'string')],
  BooleanValue: [_utilsRuleHelpers.t('Name', 'builtin')],
  EnumValue: [name('string-2')],
  ListValue: [_utilsRuleHelpers.p('['), _utilsRuleHelpers.list('Value'), _utilsRuleHelpers.p(']')],
  ObjectValue: [_utilsRuleHelpers.p('{'), _utilsRuleHelpers.list('ObjectField'), _utilsRuleHelpers.p('}')],
  ObjectField: [name('attribute'), _utilsRuleHelpers.p(':'), 'Value'],
  Type: function Type(token) {
    return token.value === '[' ? 'ListType' : 'NamedType';
  },
  // NonNullType has been merged into ListType and NamedType to simplify.
  ListType: [_utilsRuleHelpers.p('['), 'Type', _utilsRuleHelpers.p(']'), _utilsRuleHelpers.opt(_utilsRuleHelpers.p('!'))],
  NamedType: [name('atom'), _utilsRuleHelpers.opt(_utilsRuleHelpers.p('!'))],
  Directive: [_utilsRuleHelpers.p('@', 'meta'), name('meta'), _utilsRuleHelpers.opt('Arguments')],
  // GraphQL schema language
  SchemaDef: [word('schema'), _utilsRuleHelpers.list('Directive'), _utilsRuleHelpers.p('{'), _utilsRuleHelpers.list('OperationTypeDef'), _utilsRuleHelpers.p('}')],
  OperationTypeDef: [name('keyword'), _utilsRuleHelpers.p(':'), name('atom')],
  ScalarDef: [word('scalar'), name('atom'), _utilsRuleHelpers.list('Directive')],
  ObjectTypeDef: [word('type'), name('atom'), _utilsRuleHelpers.opt('Implements'), _utilsRuleHelpers.list('Directive'), _utilsRuleHelpers.p('{'), _utilsRuleHelpers.list('FieldDef'), _utilsRuleHelpers.p('}')],
  Implements: [word('implements'), _utilsRuleHelpers.list(name('atom'))],
  FieldDef: [name('property'), _utilsRuleHelpers.opt('ArgumentsDef'), _utilsRuleHelpers.p(':'), 'Type', _utilsRuleHelpers.list('Directive')],
  ArgumentsDef: [_utilsRuleHelpers.p('('), _utilsRuleHelpers.list('InputValueDef'), _utilsRuleHelpers.p(')')],
  InputValueDef: [name('attribute'), _utilsRuleHelpers.p(':'), 'Type', _utilsRuleHelpers.opt('DefaultValue'), _utilsRuleHelpers.list('Directive')],
  InterfaceDef: [word('interface'), name('atom'), _utilsRuleHelpers.list('Directive'), _utilsRuleHelpers.p('{'), _utilsRuleHelpers.list('FieldDef'), _utilsRuleHelpers.p('}')],
  UnionDef: [word('union'), name('atom'), _utilsRuleHelpers.list('Directive'), _utilsRuleHelpers.p('='), name('atom'), _utilsRuleHelpers.list('UnionMember')],
  UnionMember: [_utilsRuleHelpers.p('|'), name('atom')],
  EnumDef: [word('enum'), name('atom'), _utilsRuleHelpers.list('Directive'), _utilsRuleHelpers.p('{'), _utilsRuleHelpers.list('EnumValueDef'), _utilsRuleHelpers.p('}')],
  EnumValueDef: [name('string-2'), _utilsRuleHelpers.list('Directive')],
  InputDef: [word('input'), name('atom'), _utilsRuleHelpers.list('Directive'), _utilsRuleHelpers.p('{'), _utilsRuleHelpers.list('InputValueDef'), _utilsRuleHelpers.p('}')],
  ExtendDef: [word('extend'), 'ObjectTypeDef'],
  DirectiveDef: [word('directive'), _utilsRuleHelpers.p('@', 'meta'), name('meta'), _utilsRuleHelpers.opt('ArgumentsDef'), word('on'), name('string-2'), _utilsRuleHelpers.list('DirectiveLocation')],
  DirectiveLocation: [_utilsRuleHelpers.p('|'), name('string-2')]
};

exports.ParseRules = ParseRules;
// A keyword Token.
function word(value) {
  return {
    style: 'keyword',
    match: function match(token) {
      return token.kind === 'Name' && token.value === value;
    }
  };
}

// A Name Token which will decorate the state with a `name`.
function name(style) {
  return {
    style: style,
    match: function match(token) {
      return token.kind === 'Name';
    },
    update: function update(state, token) {
      state.name = token.value;
    }
  };
}

// A Name Token which will decorate the previous state with a `type`.
function type(style) {
  return {
    style: style,
    match: function match(token) {
      return token.kind === 'Name';
    },
    update: function update(state, token) {
      state.prevState.type = token.value;
    }
  };
}